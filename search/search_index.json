{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HELLO! Work in progress!","title":"Home"},{"location":"#hello","text":"","title":"HELLO!"},{"location":"#work-in-progress","text":"","title":"Work in progress!"},{"location":"library/a30/packages/","text":"","title":"-> Packages"},{"location":"library/a30/research/analogue/","text":"main.c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <sys/types.h> #include <sys/stat.h> #include <fcntl.h> #include <termios.h> #include <errno.h> #include <string.h> #include <unistd.h> #include <pthread.h> #include <linux/input.h> #include <stdint.h> int uart_open ( const char * port ) { int fd ; fd = open ( port , O_RDWR | O_NOCTTY | O_NDELAY ); if ( -1 == fd ) { perror ( \"Can't Open Serial Port\" ); return -1 ; } if ( fcntl ( fd , F_SETFL , 0 ) < 0 ) { printf ( \"fcntl failed! \\n \" ); return -1 ; } printf ( \"serial open=%d \\n \" , fd ); return fd ; } void uart_close ( int fd ) { close ( fd ); } int uart_set ( int fd , int speed , int flow_ctrl , int databits , int stopbits , int parity ) { int i ; int speed_arr [] = { B115200 , B19200 , B9600 , B4800 , B2400 , B1200 , B300 }; int name_arr [] = { 115200 , 19200 , 9600 , 4800 , 2400 , 1200 , 300 }; struct termios options ; if ( tcgetattr ( fd , & options ) != 0 ) { perror ( \"SetupSerial 1\" ); return -1 ; } for ( i = 0 ; i < sizeof ( speed_arr ) / sizeof ( int ); i ++ ) { if ( speed == name_arr [ i ]) { cfsetispeed ( & options , speed_arr [ i ]); cfsetospeed ( & options , speed_arr [ i ]); } } options . c_cflag |= CLOCAL ; options . c_cflag |= CREAD ; switch ( flow_ctrl ) { case 0 : options . c_cflag &= ~ CRTSCTS ; break ; case 1 : options . c_cflag |= CRTSCTS ; break ; case 2 : options . c_cflag |= IXON | IXOFF | IXANY ; break ; } options . c_cflag &= ~ CSIZE ; switch ( databits ) { case 5 : options . c_cflag |= CS5 ; break ; case 6 : options . c_cflag |= CS6 ; break ; case 7 : options . c_cflag |= CS7 ; break ; case 8 : options . c_cflag |= CS8 ; break ; default : fprintf ( stderr , \"Unsupported data size \\n \" ); return -1 ; } switch ( parity ) { case 'n' : case 'N' : options . c_cflag &= ~ PARENB ; options . c_iflag &= ~ INPCK ; break ; case 'o' : case 'O' : options . c_cflag |= ( PARODD | PARENB ); options . c_iflag |= INPCK ; break ; case 'e' : case 'E' : options . c_cflag |= PARENB ; options . c_cflag &= ~ PARODD ; options . c_iflag |= INPCK ; break ; case 's' : case 'S' : options . c_cflag &= ~ PARENB ; options . c_cflag &= ~ CSTOPB ; break ; default : fprintf ( stderr , \"Unsupported parity \\n \" ); return -1 ; } switch ( stopbits ) { case 1 : options . c_cflag &= ~ CSTOPB ; break ; case 2 : options . c_cflag |= CSTOPB ; break ; default : fprintf ( stderr , \"Unsupported stop bits \\n \" ); return -1 ; } options . c_oflag &= ~ OPOST ; options . c_lflag &= ~ ( ICANON | ECHO | ECHOE | ISIG ); // 0x0D 0x0A options . c_iflag &= ~ ( INLCR | ICRNL | IGNCR ); options . c_oflag &= ~ ( ONLCR | OCRNL ); options . c_cc [ VTIME ] = 1 ; options . c_cc [ VMIN ] = 1 ; tcflush ( fd , TCIFLUSH ); if ( tcsetattr ( fd , TCSANOW , & options ) != 0 ) { perror ( \"com set error! \\n \" ); return -1 ; } return 0 ; } int uart_init ( int fd , int speed , int flow_ctrl , int databits , int stopbits , int parity ) { if ( uart_set ( fd , speed , flow_ctrl , databits , stopbits , parity ) == -1 ) { return -1 ; } else { return 0 ; } } int uart_read ( int fd , char * rcv_buf , int data_len ) { int len , fs_sel ; fd_set fs_read ; struct timeval time ; FD_ZERO ( & fs_read ); FD_SET ( fd , & fs_read ); time . tv_sec = 10 ; time . tv_usec = 0 ; fs_sel = select ( fd + 1 , & fs_read , NULL , NULL , & time ); // printf(\"fs_sel = %d\\n\",fs_sel); if ( fs_sel ) { len = read ( fd , rcv_buf , data_len ); return len ; } else { return 0 ; } } // int uart_write(int fd, char *send_buf, int data_len) // { // int len = 0; // len = write(fd, send_buf, data_len); // if (len == data_len) // { // printf(\"send data: %s\\n\", send_buf); // return len; // } // else // { // tcflush(fd, TCOFLUSH); // return -1; // } // } void dump_cmd_frame ( const char * buf , int len ) { int i ; // printf(\"dump_cmd_frame: \\n\"); for ( i = 0 ; i < len ; i ++ ) { printf ( \" %02X\" , buf [ i ] & 0xFF ); } printf ( \" \\n \" ); } // MIYOO 282 #define MIYOO_AXIS_MAX_COUNT 16 #define MIYOO_PLAYER_MAGIC 0xFF #define MIYOO_PLAYER_MAGIC_END 0xFE #if 0 struct MIYOO_PAD_FRAME { uint8_t magic; uint8_t axis0; uint8_t axis1; uint8_t magicEnd; }; #define MIYOO_PAD_FRAME_LEN 4 // sizeof(struct MIYOO_PAD_FRAME) =12 ????? why #else struct MIYOO_PAD_FRAME { uint8_t magic ; uint8_t unused0 ; uint8_t unused1 ; uint8_t axis0 ; uint8_t axis1 ; uint8_t magicEnd ; }; #define MIYOO_PAD_FRAME_LEN 6 // sizeof(struct MIYOO_PAD_FRAME) =12 ????? why #endif static struct MIYOO_PAD_FRAME s_frame ; // static struct MIYOO_PAD_FRAME s_frame_last; // static uint32_t s_pkio; // static uint32_t s_pkio_last; static int32_t s_miyoo_axis [ MIYOO_AXIS_MAX_COUNT ]; static int32_t s_miyoo_axis_last [ MIYOO_AXIS_MAX_COUNT ]; // static int key_pressed(int key) // { // if (s_pkio & (1 << key) && !(s_pkio_last & (1 << key))) // return 1; // return 0; // } // static int key_released(int key) // { // if (!(s_pkio & (1 << key)) && s_pkio_last & (1 << key)) // return 1; // return 0; // } // static void check_key_event() // { // int i; // for (i = 0; i < MIYOO_IO_MAX; i++) // { // if (key_pressed(i)) // { // printf(\"pressed %s\\n\", s_btn_label[i]); // miyoo_report_key(EV_KEY, g_miyoo_key_event[i], 1); // } // if (key_released(i)) // { // printf(\"released %s\\n\", s_btn_label[i]); // miyoo_report_key(EV_KEY, g_miyoo_key_event[i], 0); // } // } // } #if 0 #define MIYOO_ADC_MAX_X (200) #define MIYOO_ADC_ZERO_X (137) #define MIYOO_ADC_MIN_X (76) #define MIYOO_ADC_MAX_Y (200) #define MIYOO_ADC_ZERO_Y (135) #define MIYOO_ADC_MIN_Y (72) #define MIYOO_ADC_DEAD_ZONE (10) #define MIYOO_AXIS_INT8_DRIFT (5) #else static int MIYOO_ADC_MAX_X = 200 ; static int MIYOO_ADC_ZERO_X = 137 ; static int MIYOO_ADC_MIN_X = 76 ; static int MIYOO_ADC_MAX_Y = 200 ; static int MIYOO_ADC_ZERO_Y = 135 ; static int MIYOO_ADC_MIN_Y = 72 ; static int MIYOO_ADC_DEAD_ZONE = 10 ; static int MIYOO_AXIS_INT8_DRIFT = 5 ; #define JOYPAD_CONFIG_FILE \"/config/joypad.config\" static int getKeyValueDefault ( const char * str , const char * key , int defaultValue ) { int index ; char buf [ 16 ]; const char * p = strstr ( str , key ); if ( ! p ) return defaultValue ; p = strchr ( p , '=' ); if ( ! p ) return defaultValue ; memset ( buf , 0 , sizeof ( buf )); memcpy ( buf , p + 1 , 3 ); index = defaultValue ; sscanf ( buf , \"%d\" , & index ); return index ; } int fileToMem ( const char * path , void * data ) { int len , fileLen ; FILE * fp = fopen ( path , \"r\" ); if ( ! fp ) { // printf(\"can not open %s\\n\", path); return 0 ; } fseek ( fp , 0 , SEEK_END ); fileLen = ftell ( fp ); // printf(\"file %s len=%d\\n\", path, fileLen); fseek ( fp , 0 , SEEK_SET ); len = fread ( data , 1 , fileLen , fp ); fclose ( fp ); return len ; } static void defaule_cal_config () { printf ( \"defaule_cal_config \\n \" ); MIYOO_ADC_MAX_X = 200 ; MIYOO_ADC_ZERO_X = 137 ; MIYOO_ADC_MIN_X = 76 ; MIYOO_ADC_MAX_Y = 200 ; MIYOO_ADC_ZERO_Y = 135 ; MIYOO_ADC_MIN_Y = 72 ; } static void miyoo_read_cal_config () { char configBuf [ 4096 ]; memset ( configBuf , 0 , sizeof ( configBuf )); fileToMem ( JOYPAD_CONFIG_FILE , configBuf ); // static int MIYOO_ADC_MAX_X = 200; // static int MIYOO_ADC_ZERO_X = 137; // static int MIYOO_ADC_MIN_X = 76; // static int MIYOO_ADC_MAX_Y = 200; // static int MIYOO_ADC_ZERO_Y = 135; // static int MIYOO_ADC_MIN_Y = 72; // x_min=83 // x_max=195 // y_min=74 // y_max=226 // x_zero=134 // y_zero=148 MIYOO_ADC_MIN_X = getKeyValueDefault ( configBuf , \"x_min\" , 76 ); MIYOO_ADC_MAX_X = getKeyValueDefault ( configBuf , \"x_max\" , 200 ); MIYOO_ADC_MIN_Y = getKeyValueDefault ( configBuf , \"y_min\" , 72 ); MIYOO_ADC_MAX_Y = getKeyValueDefault ( configBuf , \"y_max\" , 200 ); MIYOO_ADC_ZERO_X = getKeyValueDefault ( configBuf , \"x_zero\" , 137 ); MIYOO_ADC_ZERO_Y = getKeyValueDefault ( configBuf , \"y_zero\" , 135 ); if ( MIYOO_ADC_MAX_X == MIYOO_ADC_ZERO_X || MIYOO_ADC_MIN_X == MIYOO_ADC_ZERO_X ) defaule_cal_config (); if ( MIYOO_ADC_MAX_Y == MIYOO_ADC_ZERO_Y || MIYOO_ADC_MIN_Y == MIYOO_ADC_ZERO_Y ) defaule_cal_config (); printf ( \"joystick read cal: [%d %d %d] [%d %d %d] \\n \" , MIYOO_ADC_MIN_X , MIYOO_ADC_ZERO_X , MIYOO_ADC_MAX_X , MIYOO_ADC_MIN_Y , MIYOO_ADC_ZERO_Y , MIYOO_ADC_MAX_Y ); } #endif static int filterDeadzone ( int newAxis , int oldAxis ) { // miyoo- 20220823 disable deadzone drift filter, already in MCU. #if 0 if(newAxis > MIYOO_ADC_DEAD_ZONE || newAxis < -MIYOO_ADC_DEAD_ZONE || oldAxis > MIYOO_ADC_DEAD_ZONE || oldAxis < -MIYOO_ADC_DEAD_ZONE ) return 0; if(abs(newAxis - oldAxis) < MIYOO_AXIS_INT8_DRIFT) return 1; #endif return 0 ; } static int limitValue8 ( int value ) { if ( value > 127 ) value = 127 ; else if ( value < -128 ) value = -128 ; return value ; } int g_lastX = 0 ; int g_lastY = 0 ; static void check_axis_event () { int i ; for ( i = 0 ; i < MIYOO_AXIS_MAX_COUNT ; i ++ ) { if ( s_miyoo_axis [ i ] != s_miyoo_axis_last [ i ]) { if ( ! filterDeadzone ( s_miyoo_axis [ i ], s_miyoo_axis_last [ i ])) { if ( i == 0 ) { g_lastX = limitValue8 ( s_miyoo_axis [ i ]); // miyoo_report_abs(EV_ABS, ABS_X, g_lastX); } else if ( i == 1 ) { g_lastY = limitValue8 ( s_miyoo_axis [ i ]); // miyoo_report_abs(EV_ABS, ABS_Y, g_lastY); } // printf(\"[raw ]\\t%d \\t %d\\n\", s_frame.axis0, s_frame.axis1); // printf(\"[asix]\\t%d \\t %d\\n\", g_lastX, g_lastY); } } s_miyoo_axis_last [ i ] = s_miyoo_axis [ i ]; } } int miyoo_frame_to_axis_x ( uint8_t rawX ) { int value = 0 ; if ( rawX > MIYOO_ADC_ZERO_X ) value = ( rawX - MIYOO_ADC_ZERO_X ) * 126 / ( MIYOO_ADC_MAX_X - MIYOO_ADC_ZERO_X ); if ( rawX < MIYOO_ADC_ZERO_X ) value = ( rawX - MIYOO_ADC_ZERO_X ) * 126 / ( MIYOO_ADC_ZERO_X - MIYOO_ADC_MIN_X ); if ( value > 0 && value < MIYOO_ADC_DEAD_ZONE ) return 0 ; if ( value < 0 && value > - ( MIYOO_ADC_DEAD_ZONE )) return 0 ; return value ; } int miyoo_frame_to_axis_y ( uint8_t rawY ) { int value = 0 ; if ( rawY > MIYOO_ADC_ZERO_Y ) value = ( rawY - MIYOO_ADC_ZERO_Y ) * 126 / ( MIYOO_ADC_MAX_Y - MIYOO_ADC_ZERO_Y ); if ( rawY < MIYOO_ADC_ZERO_Y ) value = ( rawY - MIYOO_ADC_ZERO_Y ) * 126 / ( MIYOO_ADC_ZERO_Y - MIYOO_ADC_MIN_Y ); if ( value > 0 && value < MIYOO_ADC_DEAD_ZONE ) return 0 ; if ( value < 0 && value > - ( MIYOO_ADC_DEAD_ZONE )) return 0 ; return value ; } static void parser_miyoo_input ( const char * cmd , int len ) { int i , p ; // printf(\"len=%d, size=%d\\n\", len, sizeof(s_frame)); if ( ! cmd || len < MIYOO_PAD_FRAME_LEN ) return ; for ( i = 0 ; i < len - MIYOO_PAD_FRAME_LEN + 1 ; i += MIYOO_PAD_FRAME_LEN ) { for ( p = 0 ; p < MIYOO_PAD_FRAME_LEN - 1 ; p ++ ) { if (( cmd [ i ] == MIYOO_PLAYER_MAGIC ) && ( cmd [ i + MIYOO_PAD_FRAME_LEN - 1 ] == MIYOO_PLAYER_MAGIC_END )) { memcpy ( & s_frame , cmd + i , sizeof ( s_frame )); break ; } else i ++ ; } } s_miyoo_axis [ ABS_X ] = miyoo_frame_to_axis_x ( s_frame . axis0 ); s_miyoo_axis [ ABS_Y ] = miyoo_frame_to_axis_y ( s_frame . axis1 ); check_axis_event (); } #define SERIAL_GAMEDECK (\"/dev/ttyS0\") static pthread_t ntid ; static volatile int s_serial_run = 0 ; static int s_fd = -1 ; void * thread_serial_gamedeck ( void * arg ) { int len ; int i ; char rcv_buf [ 100 ]; printf ( \"thread serial joystick \\n \" ); while ( s_serial_run ) { len = uart_read ( s_fd , rcv_buf , 99 ); if ( len > 0 ) { rcv_buf [ len ] = '\\0' ; // dump_cmd_frame(rcv_buf, len); // parser_miyoo_input(rcv_buf, len); parser_miyoo_input ( rcv_buf , len ); } else { printf ( \"cannot receive data \\n \" ); } usleep ( 14 ); // sleep(2); } uart_close ( s_fd ); s_fd = -1 ; } int miyoo_init_serial_input () { int err ; miyoo_read_cal_config (); // miyoo_create_ukey(); memset ( & s_frame , 0 , sizeof ( s_frame )); // memset(&s_frame_last, 0, sizeof(s_frame_last)); memset ( s_miyoo_axis , 0 , sizeof ( s_miyoo_axis )); memset ( s_miyoo_axis_last , 0 , sizeof ( s_miyoo_axis_last )); s_fd = uart_open ( SERIAL_GAMEDECK ); err = uart_init ( s_fd , 9600 , 0 , 8 , 1 , 'N' ); if ( s_fd <= 0 ) { printf ( \"open %s error. \\n \" , SERIAL_GAMEDECK ); return -1 ; } s_serial_run = 1 ; err = pthread_create ( & ntid , NULL , thread_serial_gamedeck , NULL ); return 0 ; } void miyoo_close_serial_input () { s_serial_run = 0 ; }","title":"-> Analogue Logic"},{"location":"library/a30/research/disable_blue_led/","text":"Disable BLUE LED (Default is 255) root@MIYOO282:/# echo 0 > /sys/devices/platform/axp22_board/axp22-supplyer.20/subsystem/devices/sunxi-led/leds/led1/brightness root@MIYOO282:/# Enable BLUE LED (Default is 255) root@MIYOO282:/#echo 255 > /sys/devices/platform/axp22_board/axp22-supplyer.20/subsystem/devices/sunxi-led/leds/led1/brightness root@MIYOO282:/#","title":"-> Disable Blue LED"},{"location":"library/a30/research/events/","text":"evtest evtest Binary evtest - a binbary used for monitor event endpoints Click here /mnt/SDCARD # ./evtest No device specified, trying to scan all of /dev/input/event* Available devices: /dev/input/event0: axp22-supplyer /dev/input/event1: sunxi-keyboard /dev/input/event2: headset /dev/input/event3: sunxi-ths /dev/input/event4: gpio-keys-polled Select the device event number [0-4]: Event0 (axp22-supplyer): Input device name: \"axp22-supplyer\" Supported events: Event type 0 (EV_SYN) Event type 1 (EV_KEY) Event code 116 (KEY_POWER) Event code 143 (KEY_WAKEUP) Event type 2 (EV_REL) Properties: Event1 (sunxi-keyboard): Input device name: \"sunxi-keyboard\" Supported events: Event type 0 (EV_SYN) Event type 1 (EV_KEY) Event code 28 (KEY_ENTER) Event code 102 (KEY_HOME) Event code 114 (KEY_VOLUMEDOWN) Event code 115 (KEY_VOLUMEUP) Event code 139 (KEY_MENU) Properties: Event2 (headset): Input device name: \"headset\" Supported events: Event type 0 (EV_SYN) Event type 1 (EV_KEY) Event code 114 (KEY_VOLUMEDOWN) Event code 115 (KEY_VOLUMEUP) Event code 211 (KEY_HP) Event code 226 (KEY_MEDIA) Properties: Event3 (sunxi-ths): Input device name: \"sunxi-ths\" Supported events: Event type 0 (EV_SYN) Event type 3 (EV_ABS) Event code 40 (ABS_MISC) Value 0 Min -50 Max 180 Properties: Event4 (gpio-keys-polled): Input device name: \"gpio-keys-polled\" Supported events: Event type 0 (EV_SYN) Event type 1 (EV_KEY) Event code 1 (KEY_ESC) Event code 14 (KEY_BACKSPACE) Event code 15 (KEY_TAB) Event code 18 (KEY_E) Event code 20 (KEY_T) Event code 28 (KEY_ENTER) Event code 29 (KEY_LEFTCTRL) Event code 42 (KEY_LEFTSHIFT) Event code 56 (KEY_LEFTALT) Event code 57 (KEY_SPACE) Event code 97 (KEY_RIGHTCTRL) Event code 103 (KEY_UP) Event code 105 (KEY_LEFT) Event code 106 (KEY_RIGHT) Event code 108 (KEY_DOWN) Event code 114 (KEY_VOLUMEDOWN) Event code 115 (KEY_VOLUMEUP) Properties:","title":"-> Event Endpoints"},{"location":"library/misc/chainner/","text":"chaiNNer Using ChaiNNer to automate tasks Image AI rescaling example: Model used: https://openmodeldb.info/models/4x-UniversalUpscalerV2-Sharp Manager menu setup document.addEventListener('DOMContentLoaded', function() { const repoUrl = 'https://api.github.com/repos/chaiNNer-org/chaiNNer'; fetchGitHubRepo(repoUrl); });","title":"-> chaiNNer automation"},{"location":"library/misc/docker/","text":"Setting up WSL2, Docker, and running your first container. WSL (Windows Subsystem for Linux) WSL, or Windows Subsystem for Linux, is a handy feature for Windows users who want to run Linux without all the hassle. It lets you open up a Linux terminal right on your Windows machine, so you can use Linux commands and tools without needing a separate Linux computer or a virtual machine. It's perfect for developers and anyone who likes the flexibility of Linux but prefers sticking with Windows for their day-to-day stuff. Docker Docker is like having a magic box for your apps. You put your application and everything it needs to run (like code, libraries, and settings) into this box, called a container. Then, you can run this container on any machine with Docker installed, and it will work exactly the same. It's super useful because it means your app can run anywhere, from your laptop to a big server in the cloud, without any weird issues popping up. Plus, it makes sharing your app with others a breeze.. We use Docker for compiling as the container can be started/stopped at will and also resets the rootfs every boot. WSL and Docker What we'll be doing: Enable WSL and set WSL2 as default. Install a Linux distribution from Microsoft Store. Install Docker Desktop and enable WSL2 integration. Install Git and Make in your WSL terminal. Clone a repository and build the Docker image. Step 1: Enable WSL and Install WSL2 Enable WSL: Open PowerShell as Administrator and run: wsl - -install Set WSL2 as the Default Version: wsl - -set-default-version 2 Restart Your Computer: Restart your computer to apply changes. Step 2: Install a Linux Distribution Install a Linux Distribution: Open Microsoft Store, search for your preferred Linux distribution (e.g., Ubuntu), and install it. Set Up Your Linux Distribution: Launch the installed distribution from the Start menu and complete the initial setup (create a user account and set a password). Step 3: Install Docker Desktop Download Docker Desktop: Docker's official website Enable WSL2 Integration: During the installation, ensure the option \"Use the WSL 2 based engine\" is checked. Finish Installation: Complete the installation and start Docker Desktop. Step 4: Configure Docker to Use WSL2 Open Docker Desktop: Go to Settings. Enable WSL2 Integration: Navigate to Resources -> WSL Integration . Ensure that the Linux distribution you installed is checked to enable integration. Step 5: Install Make and Git in WSL Open WSL Terminal: Open your installed Linux distribution from the Start menu. Update Package Lists: sudo apt update Install Git and Make: sudo apt install git make Step 6: Clone the Repository and Build the Docker Image The Union toolchain is a pre-built toolchain by Shauninman. It contains everything you need to compile for the Miyoo Mini(&Plus) Clone the Repository: git clone https://github.com/shauninman/union-miyoomini-toolchain.git Navigate to the Directory: cd union-miyoomini-toolchain Build and Run the Docker Container: make shell mattpc@MattPC:~/union-miyoomini-toolchain$ make shell docker run -it --rm -v \"/home/mattpc/union-miyoomini-toolchain/workspace\":/root/workspace miyoomini-toolchain /bin/bash root@7ee8499587da:~/workspace# You're now in a containerised shell and can begin compiling; why not try this script out to compile your first Miyoo compatible binary? The Hello-Miyoo test app","title":"-> Docker Setup"},{"location":"library/miyoo/apps/","text":"document.addEventListener('DOMContentLoaded', function() { const repoConfigs = [ { url: 'https://api.github.com/repos/XK9274/syncthing-app-miyoo', title: 'Syncthing', description: 'Syncthing is a continuous file synchronization program. It synchronizes files between two or more computers in real time, safely protected from prying eyes. Your data is your data alone and you deserve to choose where it is stored, whether it is shared with some third party, and how it\u2019s transmitted over the internet.', type: 'App' }, { url: 'https://api.github.com/repos/steward-fu/sdl2', title: 'SDL2 (Miyoo flavour)', description: 'A custom SDL2 implementation for the Miyoo Mini and Miyoo Mini Plus (Sigmastar SSD202D)', type: 'App' }, { url: 'https://api.github.com/repos/XK9274/sdl2_miyoo', title: 'SDL2 (Miyoo flavour)', description: 'A custom SDL2 implementation for the Miyoo Mini and Miyoo Mini Plus (Sigmastar SSD202D)', type: 'App' }, { url: 'https://api.github.com/repos/XK9274/pico-8-wrapper-miyoo', title: 'Pico-8 Wrapper', description: 'A wrapper to run Pico-8 Native on the Miyoo Mini/Miyoo Mini Plus.', type: 'App' }, { url: 'https://api.github.com/repos/XK9274/moonlight-app-miyoo', title: 'Moonlight App', description: 'Moonlight client app for the Miyoo Mini +', type: 'App' }, { url: 'https://api.github.com/repos/XK9274/ncspotcli-compile-miyoo', title: 'ncspot CLI', description: 'A CLI for ncspot compiled for Miyoo.', type: 'App' }, { url: 'https://api.github.com/repos/XK9274/blobbyvolley2-miyoo', title: 'Blobby Volley 2', description: 'Blobby Volley 2 compiled for Miyoo.', type: 'Game' } ]; checkRateLimit(repoConfigs); }); async function checkRateLimit(repoConfigs) { try { const response = await fetch('https://api.github.com/rate_limit'); const data = await response.json(); if (data.resources.core.remaining > 0) { repoConfigs.forEach(config => fetchGitHubRepo(config.url, config.title, config.description, config.type)); } else { repoConfigs.forEach(config => displayManualCard(config.title, config.description, config.url, config.type)); } } catch (error) { console.error('Error checking rate limit:', error); repoConfigs.forEach(config => displayManualCard(config.title, config.description, config.url, config.type)); } } async function fetchGitHubRepo(repoUrl, title, description, type) { try { const response = await fetch(repoUrl); const repoData = await response.json(); const userResponse = await fetch(repoData.owner.url); const userData = await userResponse.json(); displayRepoCard(repoData, userData, title, description, type); } catch (error) { console.error('Error fetching GitHub data:', error); displayManualCard(title, description, repoUrl, type); } } function displayRepoCard(repoData, userData, title, description, type) { const centerContainer = document.querySelector('.center-container-gen'); const cardContainer = document.createElement('div'); cardContainer.className = 'drac-app-container'; cardContainer.innerHTML = ` <div class=\"top-section\"> <div class=\"top-bar ${type.toLowerCase()}-gradient\"> <div class=\"type-text\">${type}</div> </div> <div class=\"top-text\">${title}</div> </div> <div class=\"bottom-section\"> <div class=\"manual-card\"> <h2>${title}</h2> <p>Description: ${description}</p> </div> <div class=\"github-card streamlined-card\"> <a href=\"${repoData.html_url}\" target=\"_blank\" style=\"text-decoration: none; color: inherit;\"> <div class=\"streamlined-card-header\">GitHub Repo</div> <div class=\"streamlined-card-content\"> <div class=\"streamlined-card-details\"> <p class=\"streamlined-repo-name\">${repoData.name}</p> <p class=\"streamlined-author-name\">by ${userData.login}</p> <p class=\"repo-description\">${repoData.description}</p> </div> </div> </a> </div> </div> `; cardContainer.querySelector('.github-card').style.backgroundImage = `linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.6)), url(${userData.avatar_url})`; cardContainer.querySelector('.github-card').style.backgroundSize = 'cover'; cardContainer.querySelector('.github-card').style.backgroundPosition = 'center'; centerContainer.appendChild(cardContainer); } function displayManualCard(title, description, repoUrl, type) { const centerContainer = document.querySelector('.center-container-gen'); const cardContainer = document.createElement('div'); cardContainer.className = 'drac-app-container'; cardContainer.innerHTML = ` <div class=\"top-section\"> <div class=\"top-bar ${type.toLowerCase()}-gradient\"> <div class=\"type-text\">${type}</div> </div> <div class=\"top-text\">${title}</div> </div> <div class=\"bottom-section\"> <div class=\"manual-card\"> <h2>${title}</h2> <p>Description: ${description}</p> <p><a href=\"${repoUrl}\" target=\"_blank\" style=\"color: var(--green);\">GitHub Repo</a></p> </div> </div> `; centerContainer.appendChild(cardContainer); } document.addEventListener('DOMContentLoaded', function() { const driveFiles = [ { title: 'MGBA SDL2 Standalone', description: 'Standalone mGBA Emulator test for MMP', type: 'Game', url: 'https://drive.google.com/file/d/1V-Ju8EfuPN2gsOURReHVUubAGGuljmnp/view?usp=sharing', imgSrc: '/assets/images/icon/icons8-google-drive-48.png' }, { title: 'evtest', description: 'evtest - a binary used for monitoring event endpoints', type: 'App', url: 'https://drive.google.com/file/d/1zHz70U39K2dKxtoPDKpACvPdfPebDdvf/view?usp=sharing', imgSrc: '/assets/images/icon/icons8-google-drive-48.png' }, { title: 'Mono', description: 'Mono package, compatible with MM/MM+', type: 'App', url: 'https://drive.google.com/file/d/1Rd0G12cQyfiqTDp_M5aXyrzqgJb_SxLl/view?usp=sharing', imgSrc: '/assets/images/icon/icons8-google-drive-48.png' }, { title: 'ZSH', description: 'ZSH w/ Regex package, compatible with MM/MM+', type: 'App', url: 'https://drive.google.com/file/d/1wuxg68SdRfU1oOA8hXhLsGORGqfeU93v/view?usp=sharing', imgSrc: '/assets/images/icon/icons8-google-drive-48.png' } ]; displayDriveCards(driveFiles); }); function displayDriveCards(files) { const centerContainer = document.querySelector('.center-container-gen-drive'); files.forEach(file => { const cardContainer = document.createElement('div'); cardContainer.className = 'google-drive-card'; cardContainer.innerHTML = ` <div class=\"card-header\">${file.title}</div> <div class=\"card-content\"> <img src=\"${file.imgSrc}\" alt=\"Drive File Thumbnail\"> <div class=\"card-details\"> <p class=\"drive-file-name\">${file.title}</p> <p class=\"drive-file-type\">${file.type}</p> <p class=\"drive-file-description\">${file.description}</p> </div> </div> <div class=\"card-footer\"> <a href=\"${file.url}\" target=\"_blank\" style=\"color: var(--green);\">Download</a> </div> `; centerContainer.appendChild(cardContainer); }); }","title":"-> Apps/Games"},{"location":"library/miyoo/compiling/ffmpeg/","text":"","title":"FFMPEG"},{"location":"library/miyoo/compiling/hello-miyoo/","text":"Compiling a demo application to run on the Miyoo Compiling your first app can be daunting, let's get you setup! WSL and Docker What we'll be doing: Using docker to start a container Cloning a demo repository Compiling an application as armhf Running the app on device Step 1: Make sure you have WSL2 and Docker setup: Setup WSL2 and Docker Click here: Setup WSL2 and Docker Step 2: Open a terminal and cd to your WSL2 home location Open WSL2 Terminal: Open your installed Linux distribution from the Start menu (or right click in a directory and click \"Open in terminal\") Change Directory to Home: cd ~ Step 3: Clone and start the docker environment Clone the Union Miyoo Mini Toolchain Repository: git clone https://github.com/shauninman/union-miyoomini-toolchain.git Navigate to the Directory: cd union-miyoomini-toolchain Build and Run the Docker Environment: make shell Step 4: Clone the \"hello-miyoo-c\" project Clone the Project Repository: git clone https://github.com/XK9274/hello-miyoo-c.git Navigate to the Project Directory: cd hello-miyoo-c Step 5: Enter and build (make) the project Build the Project: make root@29fa0688544a:~/workspace/hello_world# make /opt/miyoomini-toolchain/usr/bin/arm-linux-gnueabihf-gcc main.c -o hellomiyoo -marm -mtune=cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=hard -march=armv7ve root@29fa0688544a:~/workspace/hello_world# Step 6: Check we've compiled against the correct arch Let's check that we actually did crosscompile the binary to armhf! root@29fa0688544a:~/workspace/hello_world# file ./hellomiyoo ./hellomiyoo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 3.2.0, with debug_info, not stripped root@29fa0688544a:~/workspace/hello_world# root@29fa0688544a:~/workspace/hello_world# Great! Step 7: Time to copy to your device and run it! We need to get the file over to the Miyoo now! You can either pull the SDCARD or: Copying the Built Project to Your Device: Use your weapon of choice for getting the file onto the device, some options here are: Samba HTTP SSH FTP Step 8: Run the app! Browse to the location you added the binary to the device using Telnet or SSH and run it! For example; I've added the hello-miyoo file to the SDCARD root: /mnt/SDCARD # ./hellomiyoo Hello! Congratulations!! Current date and time: 2024-05-22 20:20:09 Screen width: 640, Screen height: 480 /mnt/SDCARD # Or, through the Simple Terminal app: Success!","title":"Hello Miyoo"},{"location":"library/miyoo/compiling/moonlight/","text":"","title":"Moonlight"},{"location":"library/miyoo/compiling/python39/","text":"","title":"Python3.9"},{"location":"library/miyoo/compiling/scummvm/","text":"","title":"ScummVM"},{"location":"library/miyoo/compiling/sdl2/","text":"","title":"SDL2"},{"location":"library/miyoo/compiling/terminfo/","text":"Terminfo Terminfo Directory Terminfo files compatible with Miyoo Mini/Plus Click here","title":"Terminfo"},{"location":"library/miyoo/mi_x/mi_ao/","text":"MI_AO Documentation MI_AO (Audio Output) Sigmastar API Overview of MI_AO: MI_AO manages the audio output settings such as volume and mute state. It is capable of handling different audio channels and provides a command interface for setting audio parameters. Hey! some info for you! - Only one instance of AO can be spawned at any given time! - If your app is going to spawn one, you'll need to kill audioserver before getting started! - You can do this by running `. /mnt/SDCARD/.tmp_update/script/stop_audioserver.sh` Example of MI_AO Commands: set_ao_mute [ON/on/1, OFF/off/0]; Enable/Disable AO mute. set_ao_volume [ChnID] [-60 ~ 30dB]; Set AO volume. set_ao_src_volume [ChnID] [-60 ~ 30dB]; Set AO Src volume. dump [Path] [FrameCount]; Dump pcm data. Example of MI_AO status output: /proc/mi_modules/mi_panel # cat ../mi_disp/mi_disp0 -----------------------------------------Common info for mi_disp----------------------------------------- ChnNum EnChnNum PassNum InPortNum OutPortNum CollectSize 17 1 1 1 0 0 ----------------------CMDQ kickoff counter----------------------- ------------------------------Common info formi_disp only dump enabled chn------------------------------ ChnId PassNum EnInPNum EnOutPNum MMAHeapName 0 0 1 0 (null) -------------------------Input port common info for mi_disp only dump enabled port--------------------- ChnId PassId PortId user_buf_quota UsrInjectQ_cnt BindInQ_cnt TotalPendingBuf_size usrLockedInjectCnt 0 0 0 4 0 0 0 0 ChnId PassId PortId newPulseQ_cnt nextTodoPulseQ_cnt curWorkingQ_cnt workingTask_cnt lazzyRewindTask_cnt 0 0 0 0 0 0 0 0 ChnId PassId PortId Enable bind_module_id bind_module_name bind_ChnId bind_PortId bind_Type bind_Param enable ChnId PassId PortId LowLatencyDelayMs LastStaticDelayAveMS ChnId PassId PortId SrcFrmrate DstFrmrate RealSrcFrmrate FPS FinishCnt RewindCnt 0 0 0 0/ 0 0/ 0 0/ 0 0.00 0 0 ----------------------Output port common info for mi_disp only for enabled port--------------------- ChnId PassId PortId usrDepth BufCntQuota usrLockedCnt totalOutPortInUsed DrvBkRefFifoQ_cnt DrvBkRefFifoQ_size ChnId PassId PortId RealDstFrmrate FPS UsrGetFifoQ_cnt UsrGetFifoQ_size UsrGetFifoQ_seqnum UsrGetFifoQ_discardnum ChnId PassId PortId workingTask_cnt finishedTask_cnt ChnId PassId PortId RealDstFrmrate FPS FinishCnt RewindCnt GetTotalCnt GetOkCnt ----------------------------------------BindPeerInputPortList--------------------------------------- ChnId PassId PortId Enable bind_module_id bind_module_name bind_ChnId bind_PortId bind_Type bind_Param enable ============================== Private DISP0 Info ============================ DevStatus IrqNum IrqCnt BgColor 1 57 27436 800080 Interface DevTiming CscMatrix Luma Contrast Hue Saturation Sharpness LCD UNKNOWN 3 42 50 50 50 0 --------------------------------- Layer Info --------------------------------- LayerId BindedDevID LayerWidth LayerHeight 0 0 0 0 LayerId LayDispWidth LayDispHeight Toleration rotatemode 0 0 0 0 NONE --------------------------------- Layer0 InputPort Info --------------------------------- PortId enable CurStatus src_w src_h crop_x crop_y crop_w crop_h show_x show_y show_w show_h 0 1 0 640 480 0 0 0 0 0 0 640 480 1 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 9 0 0 0 0 0 0 0 0 0 0 0 0 10 0 0 0 0 0 0 0 0 0 0 0 0 11 0 0 0 0 0 0 0 0 0 0 0 0 12 0 0 0 0 0 0 0 0 0 0 0 0 13 0 0 0 0 0 0 0 0 0 0 0 0 14 0 0 0 0 0 0 0 0 0 0 0 0 15 0 0 0 0 0 0 0 0 0 0 0 0 PortId RecvBufCnt RecvBuf_W RecvBuf_H Content_W Content_H RecvBufStride PixFmt syncmode 0 0 0 0 0 0 0 yuv422_yuyv FreeRun 1 0 0 0 0 0 0 yuv422_yuyv Invalid 2 0 0 0 0 0 0 yuv422_yuyv Invalid 3 0 0 0 0 0 0 yuv422_yuyv Invalid 4 0 0 0 0 0 0 yuv422_yuyv Invalid 5 0 0 0 0 0 0 yuv422_yuyv Invalid 6 0 0 0 0 0 0 yuv422_yuyv Invalid 7 0 0 0 0 0 0 yuv422_yuyv Invalid 8 0 0 0 0 0 0 yuv422_yuyv Invalid 9 0 0 0 0 0 0 yuv422_yuyv Invalid 10 0 0 0 0 0 0 yuv422_yuyv Invalid 11 0 0 0 0 0 0 yuv422_yuyv Invalid 12 0 0 0 0 0 0 yuv422_yuyv Invalid 13 0 0 0 0 0 0 yuv422_yuyv Invalid 14 0 0 0 0 0 0 yuv422_yuyv Invalid 15 0 0 0 0 0 0 yuv422_yuyv Invalid PortId OnScreenTask FiredTask PendingTak LastDropTask DropTaskCnt StepTaskCnt bClearAllTask fps 0 (null) (null) (null) (null) 0 0 0 0 1 (null) (null) (null) (null) 0 0 0 0 2 (null) (null) (null) (null) 0 0 0 0 3 (null) (null) (null) (null) 0 0 0 0 4 (null) (null) (null) (null) 0 0 0 0 5 (null) (null) (null) (null) 0 0 0 0 6 (null) (null) (null) (null) 0 0 0 0 7 (null) (null) (null) (null) 0 0 0 0 8 (null) (null) (null) (null) 0 0 0 0 9 (null) (null) (null) (null) 0 0 0 0 10 (null) (null) (null) (null) 0 0 0 0 11 (null) (null) (null) (null) 0 0 0 0 12 (null) (null) (null) (null) 0 0 0 0 13 (null) (null) (null) (null) 0 0 0 0 14 (null) (null) (null) (null) 0 0 0 0 15 (null) (null) (null) (null) 0 0 0 0 /proc/mi_modules/mi_panel # Example of MI_AO interaction: Change the volume of channel 0 (-30, 30, etc): echo \"set_ao_volume 0 -20dB\" > /proc/mi_modules/mi_ao/mi_ao0 Change the volume of channel 1: echo \"set_ao_volume 1 10dB\" > /proc/mi_modules/mi_ao/mi_ao0 Change mute state (0 not muted, 1 muted): echo \"set_ao_mute 1\" > /proc/mi_modules/mi_ao/mi_ao0 document.addEventListener('DOMContentLoaded', function() { const repoUrl = 'https://api.github.com/repos/XK9274/ssd20x-SDK-en-mirror'; fetchGitHubRepo(repoUrl); });","title":"MI_AO"},{"location":"library/miyoo/mi_x/mi_disp/","text":"MI_DISP Documentation MI_DISP (Display parameters) Sigmastar API Overview of MI_DISP: MI_DISP is another interesting one, where if you enable it within a binary that binary must continue to run or MI_DISP will be disabled. An example of this is also /dev/l which initialises MI_DISP and holds it open by entering a loop, the loop breaks if you send a -2 kill into /dev/l I've found mo current way to read back pushed in CSC changes so if someone finds a way please let me know! (Store a local copy of what you set is the way around this) Modifying MI_DISP values is not a permanent change and can be reset by pushing in the default or rebooting! Hey! some info for you! - If you disable mi_disp by calling /dev/l you can spawn /dev/l again by calling `cat /proc/ls` - If mi_disp is not currently running you can *NOT* push in CSC changes! (No colour changes ie: blue light filter will stop working) Example of MI_DISP Commands: CatModuleInfo: cat /proc/mi_modules/mi_disp/mi_disp0 GetCapFrame: echo getcapframe [devid] [layerid] [path] > /proc/mi_modules/mi_disp/mi_disp0 CheckFramePts: echo checkframepts [layeid] [portid] [ON/OFF] > /proc/mi_modules/mi_disp/mi_disp0 Dumpframe: echo dumpframe [layerid] [portid] [path] > /proc/mi_modules/mi_disp/mi_disp0 StopGetBuff: echo stopgetbuff [layerid] [portid] [ON/OFF] > /proc/mi_modules/mi_disp/mi_disp0 SetBgcolor: echo bgcolor [devid] [value] > /proc/mi_modules/mi_disp/mi_disp0 SetCsc: echo csc [devid] [CscMatrix] [Contrast] [Hue] [Luma] [Saturation] [Sharpness] [Gain] > /proc/mi_modules/mi_disp/mi_disp0 setcolortemp: echo colortemp [devid] [BlueOffset] [GreenOffset] [RedOffset] [BlueColor] [GreenColor] [RedColor] > /proc/mi_modules/mi_disp/mi_disp0 setrotatemode: echo rotate [layerid] [0/1/2] > /proc/mi_modules/mi_disp/mi_disp0 setcrop: echo crop [layerid] [portid] [x] [y] [width] [height] > /proc/mi_modules/mi_disp/mi_disp0 hideport: echo hide [layerid] [portid] > /proc/mi_modules/mi_disp/mi_disp0 showport: echo show [layerid] [portid] > /proc/mi_modules/mi_disp/mi_disp0 pauseport: echo pause [layerid] [portid] > /proc/mi_modules/mi_disp/mi_disp0 resumeport: echo resume [layerid] [portid] > /proc/mi_modules/mi_disp/mi_disp0 stepport: echo step [layerid] [portid] > /proc/mi_modules/mi_disp/mi_disp0 clearport: echo clear [layerid] [portid] > /proc/mi_modules/mi_disp/mi_disp0 Example of MI_DISP status output: -----------------------------------------Common info for mi_disp----------------------------------------- ChnNum EnChnNum PassNum InPortNum OutPortNum CollectSize 17 1 1 1 0 0 ----------------------CMDQ kickoff counter----------------------- ------------------------------Common info formi_disp only dump enabled chn------------------------------ ChnId PassNum EnInPNum EnOutPNum MMAHeapName 0 0 1 0 (null) -------------------------Input port common info for mi_disp only dump enabled port--------------------- ChnId PassId PortId user_buf_quota UsrInjectQ_cnt BindInQ_cnt TotalPendingBuf_size usrLockedInjectCnt 0 0 0 4 0 0 0 0 ChnId PassId PortId newPulseQ_cnt nextTodoPulseQ_cnt curWorkingQ_cnt workingTask_cnt lazzyRewindTask_cnt 0 0 0 0 0 0 0 0 ChnId PassId PortId Enable bind_module_id bind_module_name bind_ChnId bind_PortId bind_Type bind_Param enable ChnId PassId PortId LowLatencyDelayMs LastStaticDelayAveMS ChnId PassId PortId SrcFrmrate DstFrmrate RealSrcFrmrate FPS FinishCnt RewindCnt 0 0 0 0/ 0 0/ 0 0/ 0 0.00 0 0 ----------------------Output port common info for mi_disp only for enabled port--------------------- ChnId PassId PortId usrDepth BufCntQuota usrLockedCnt totalOutPortInUsed DrvBkRefFifoQ_cnt DrvBkRefFifoQ_size ChnId PassId PortId RealDstFrmrate FPS UsrGetFifoQ_cnt UsrGetFifoQ_size UsrGetFifoQ_seqnum UsrGetFifoQ_discardnum ChnId PassId PortId workingTask_cnt finishedTask_cnt ChnId PassId PortId RealDstFrmrate FPS FinishCnt RewindCnt GetTotalCnt GetOkCnt ----------------------------------------BindPeerInputPortList--------------------------------------- ChnId PassId PortId Enable bind_module_id bind_module_name bind_ChnId bind_PortId bind_Type bind_Param enable ============================== Private DISP0 Info ============================ DevStatus IrqNum IrqCnt BgColor 1 57 27436 800080 Interface DevTiming CscMatrix Luma Contrast Hue Saturation Sharpness LCD UNKNOWN 3 42 50 50 50 0 --------------------------------- Layer Info --------------------------------- LayerId BindedDevID LayerWidth LayerHeight 0 0 0 0 LayerId LayDispWidth LayDispHeight Toleration rotatemode 0 0 0 0 NONE --------------------------------- Layer0 InputPort Info --------------------------------- PortId enable CurStatus src_w src_h crop_x crop_y crop_w crop_h show_x show_y show_w show_h 0 1 0 640 480 0 0 0 0 0 0 640 480 1 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 9 0 0 0 0 0 0 0 0 0 0 0 0 10 0 0 0 0 0 0 0 0 0 0 0 0 11 0 0 0 0 0 0 0 0 0 0 0 0 12 0 0 0 0 0 0 0 0 0 0 0 0 13 0 0 0 0 0 0 0 0 0 0 0 0 14 0 0 0 0 0 0 0 0 0 0 0 0 15 0 0 0 0 0 0 0 0 0 0 0 0 PortId RecvBufCnt RecvBuf_W RecvBuf_H Content_W Content_H RecvBufStride PixFmt syncmode 0 0 0 0 0 0 0 yuv422_yuyv FreeRun 1 0 0 0 0 0 0 yuv422_yuyv Invalid 2 0 0 0 0 0 0 yuv422_yuyv Invalid 3 0 0 0 0 0 0 yuv422_yuyv Invalid 4 0 0 0 0 0 0 yuv422_yuyv Invalid 5 0 0 0 0 0 0 yuv422_yuyv Invalid 6 0 0 0 0 0 0 yuv422_yuyv Invalid 7 0 0 0 0 0 0 yuv422_yuyv Invalid 8 0 0 0 0 0 0 yuv422_yuyv Invalid 9 0 0 0 0 0 0 yuv422_yuyv Invalid 10 0 0 0 0 0 0 yuv422_yuyv Invalid 11 0 0 0 0 0 0 yuv422_yuyv Invalid 12 0 0 0 0 0 0 yuv422_yuyv Invalid 13 0 0 0 0 0 0 yuv422_yuyv Invalid 14 0 0 0 0 0 0 yuv422_yuyv Invalid 15 0 0 0 0 0 0 yuv422_yuyv Invalid PortId OnScreenTask FiredTask PendingTak LastDropTask DropTaskCnt StepTaskCnt bClearAllTask fps 0 (null) (null) (null) (null) 0 0 0 0 1 (null) (null) (null) (null) 0 0 0 0 2 (null) (null) (null) (null) 0 0 0 0 3 (null) (null) (null) (null) 0 0 0 0 4 (null) (null) (null) (null) 0 0 0 0 5 (null) (null) (null) (null) 0 0 0 0 6 (null) (null) (null) (null) 0 0 0 0 7 (null) (null) (null) (null) 0 0 0 0 8 (null) (null) (null) (null) 0 0 0 0 9 (null) (null) (null) (null) 0 0 0 0 10 (null) (null) (null) (null) 0 0 0 0 11 (null) (null) (null) (null) 0 0 0 0 12 (null) (null) (null) (null) 0 0 0 0 13 (null) (null) (null) (null) 0 0 0 0 14 (null) (null) (null) (null) 0 0 0 0 15 (null) (null) (null) (null) 0 0 0 0 /proc/mi_modules/mi_panel # Example of MI_DISP status interaction: Off: echo \"colortemp 0 0 0 0 128 128 128\" > /proc/mi_modules/mi_disp/mi_disp0 Subtle: echo \"colortemp 0 0 0 0 115 130 140\" > /proc/mi_modules/mi_disp/mi_disp0 Moderate: echo \"colortemp 0 0 0 0 110 125 140\" > /proc/mi_modules/mi_disp/mi_disp0 Balanced: echo \"colortemp 0 0 0 0 100 120 140\" > /proc/mi_modules/mi_disp/mi_disp0 Strong: echo \"colortemp 0 0 0 0 90 115 140\" > /proc/mi_modules/mi_disp/mi_disp0 Intense: echo \"colortemp 0 0 0 0 80 110 140\" > /proc/mi_modules/mi_disp/mi_disp0 document.addEventListener('DOMContentLoaded', function() { const repoUrl = 'https://api.github.com/repos/XK9274/ssd20x-SDK-en-mirror'; fetchGitHubRepo(repoUrl); });","title":"MI_DISP"},{"location":"library/miyoo/mi_x/mi_gfx/","text":"","title":"MI_GFX"},{"location":"library/miyoo/mi_x/mi_panel/","text":"MI_PANEL Documentation MI_PANEL (Panel initialization, geometry, etc.) Sigmastar API Overview of MI_PANEL: `MI_PANEL` is responsible for setting up the display panel's parameters. It allows you to modify settings such as geometry, timing, and more. Adjustments made to these settings directly affect the hardware level of the display and should be performed with caution Hey! some info for you! - MI_PANEL has to be initialised (in C) with the required geometry data. Miyoos version isn't publicly available however, you can reverse engineer it by using the panel output data below - If you push in bad settings, you can always revert by rebooting! Example of MI_PANEL Commands: CatModuleInfo: cat /proc/mi_modules/mi_panel/mi_panel0 pattern: echo pattern [r] [g] [b] > /proc/mi_modules/mi_panel/mi_panel0 pattern: echo setssc [enable/disable] [span] [step] > /proc/mi_modules/mi_panel/mi_panel0 pattern: echo settiming [hbp] [hbp_value] [htotal] [htotal_value] > /proc/mi_modules/mi_panel/mi_panel0 pattern: echo setmipidsi [hbp] [hbp_value] > /proc/mi_modules/mi_panel/mi_panel0 Example of MI_PANEL status output: /proc/mi_modules/mi_panel # cat mi_panel0 PanelName:K101_IM2BVL --------------------------------------- PANEL Dev0 Info ------------------------------------- LVDS_POL LVDS_CH LINK_TYPE TI_MODE 0 0 MIPI_DSI 1 SW_ODD SW_EVEN SW_ODD_RB SW_EVEN_RB 0 0 0 0 H_Total V_Total Width Height H_Start V_Start 780 515 640 480 42 18 hbp hspw hfp vbp vspw vfp 24 20 96 13 5 17 DClk FrameRate INV_DCLK INV_DE InvHSync InvVSync 26 0 0 0 1 1 SSC_Enable SSC_Step SSC_Span TI_BIT Format chnswap disable 0 0 8BIT 8BIT (2,4,3,1,0) --------------------------------MIPI CONFIG------------------------------- HsTrail HsPrpr HsZero ClkHsPrpr ClkHsExit ClkTrail 3 2 5 2 4 4 ClkZero ClkHsPost DaHsExit ContDet Lpx TaGet 10 10 4 0 16 26 TaSure TaGo Hactive Hpw Hbp Hfp 22 50 640 120 120 120 Vactive Vpw Vbp Vfp Bllp Fps 480 5 13 17 0 60 lanemode format ctrlmode SyncCalibrate VirHsyncSt VirHsyncEnd VsyncRef DataClkSkew 2lane rgb888 sync_pulse 1 431 441 32978 9 PolChn0 PolChn1 PolChn2 PolChn3 PolChn4 0 0 0 0 0 /proc/mi_modules/mi_panel # Example of MI_PANEL interaction: Change the hardware back porch setting: echo \"settiming hbp 15\" > /proc/mi_modules/mi_panel/mi_panel0 Change the display width: echo \"settiming width 320\" > /proc/mi_modules/mi_panel/mi_panel0 document.addEventListener('DOMContentLoaded', function() { const repoUrl = 'https://api.github.com/repos/XK9274/ssd20x-SDK-en-mirror'; fetchGitHubRepo(repoUrl); });","title":"MI_PANEL"},{"location":"library/miyoo/mi_x/mi_sys/","text":"MI_SYS Documentation MI_SYS (The core of all mi_modules) Sigmastar API Overview of MI_SYS: `MI_SYS` is the master of other `mi_modules`. It manages buffers, memory addresses, and the binding of modules. Some modules, like `mi_divp` and `mi_vdec`, require binding to another module (like `mi_disp` or `mi_panel`) to function properly. However, `mi_gfx` operates independently, without needing bindings to other modules. Understanding Bindings and Memory Operations: For memory allocation and operations, `MI_SYS` is utilized. While `mi_gfx` relies on `MI_SYS` for memory buffers, it does not bind to any other modules and uses its own blit mechanics and functions. Before utilizing it, a panel and display should be initialized on Miyoo devices, typically done by `/dev/l` and other Miyoo-provided modules. Hey! some info for you! - You may find MI_SYS has a hard limit for buffers of 9-10mb! Example of MI_SYS status output: To check the status of `MI_SYS`, you can examine the output from the relevant `/proc/mi_modules/mi_sys` file: /proc/mi_modules/mi_sys # cat mi_sys0 -----------------------------------------Common info for mi_sys----------------------------------------- ChnNum EnChnNum PassNum InPortNum OutPortNum CollectSize 0 0 0 0 0 0 ----------------------CMDQ kickoff counter----------------------- ------------------------------Common info formi_sys only dump enabled chn------------------------------ ChnId PassNum EnInPNum EnOutPNum MMAHeapName -------------------------Input port common info for mi_sys only dump enabled port--------------------- ChnId PassId PortId user_buf_quota UsrInjectQ_cnt BindInQ_cnt TotalPendingBuf_size usrLockedInjectCnt ChnId PassId PortId newPulseQ_cnt nextTodoPulseQ_cnt curWorkingQ_cnt workingTask_cnt lazzyRewindTask_cnt ChnId PassId PortId Enable bind_module_id bind_module_name bind_ChnId bind_PortId bind_Type bind_Param enable ChnId PassId PortId LowLatencyDelayMs LastStaticDelayAveMS ChnId PassId PortId SrcFrmrate DstFrmrate RealSrcFrmrate FPS FinishCnt RewindCnt ----------------------Output port common info for mi_sys only for enabled port--------------------- ChnId PassId PortId usrDepth BufCntQuota usrLockedCnt totalOutPortInUsed DrvBkRefFifoQ_cnt DrvBkRefFifoQ_size ChnId PassId PortId RealDstFrmrate FPS UsrGetFifoQ_cnt UsrGetFifoQ_size UsrGetFifoQ_seqnum UsrGetFifoQ_discardnum ChnId PassId PortId workingTask_cnt finishedTask_cnt ChnId PassId PortId RealDstFrmrate FPS FinishCnt RewindCnt GetTotalCnt GetOkCnt ----------------------------------------BindPeerInputPortList--------------------------------------- ChnId PassId PortId Enable bind_module_id bind_module_name bind_ChnId bind_PortId bind_Type bind_Param enable /proc/mi_modules/mi_sys # document.addEventListener('DOMContentLoaded', function() { const repoUrl = 'https://api.github.com/repos/XK9274/memops-miyoo-benchmark'; fetchGitHubRepo(repoUrl); });","title":"MI_SYS"},{"location":"library/miyoo/packages/","text":"MGBA SDL2 Standalone Archive Standalone mGBA Emulator test for MMP Download evtest Binary evtest - a binary used for monitoring event endpoints Download Mono Archive Mono package, compatible with MM/MM+ Download ZSH Archive ZSH w/ Regex package, compatible with MM/MM+ Download","title":"Index"},{"location":"library/tsp/bluetooth/","text":"bluetoothctl power on scan on discoverable on remove 1C:99:57:1C:2B:85 connect 1C:99:57:1C:2B:85 pair 1C:99:57:1C:2B:85 trust 1C:99:57:1C:2B:85 sdptool browse 1C:99:57:1C:2B:85","title":"-> Bluetooth via cmdline"},{"location":"library/tsp/packages/","text":"Binutils (2.40.90) ZIP File Compiled version of Binutils Download Coreutils (9.1) ZIP File Compiled version of Coreutils Download jq (88f01a7) ZIP File Compiled version of jq Download Strace (a1bb27b) ZIP File Compiled version of Strace Download i2ctools (4.3) ZIP File Compiled version of i2ctools Download iwtools ZIP File Compiled version of iwtools Download dropbear (9925b00) ZIP File Compiled version of dropbear Download iwtools ZIP File Compiled version of iwtools Download","title":"-> Packages"}]}